<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.1.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>Dockerfile - answer0732</title>

  
    <meta name="description" content="什么是DockerfileDockerfile就是一些包含linux命令的文件，Docker通过Dockerfile读取文件中的命令来组件镜像 Dockerfile文件内容结构dockerfile一般有四个组成部分：  基础镜像信息 维护者信息 镜像操作指令和容器启动时执行指令（#号为注释部分）  运行Dockerfile1docker build -t image_name:tag_name .">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile">
<meta property="og:url" content="http://example.com/2022/04/25/Dockerfile%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="answer0732">
<meta property="og:description" content="什么是DockerfileDockerfile就是一些包含linux命令的文件，Docker通过Dockerfile读取文件中的命令来组件镜像 Dockerfile文件内容结构dockerfile一般有四个组成部分：  基础镜像信息 维护者信息 镜像操作指令和容器启动时执行指令（#号为注释部分）  运行Dockerfile1docker build -t image_name:tag_name .">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-25T04:06:00.000Z">
<meta property="article:modified_time" content="2022-04-25T04:58:42.585Z">
<meta property="article:author" content="answer0732">
<meta property="article:tag" content="工具设置">
<meta property="article:tag" content="虚拟化">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/32223506?s=96&v=4" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">answer0732</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDockerfile"><span class="toc-text">什么是Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="toc-text">Dockerfile文件内容结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CDockerfile"><span class="toc-text">运行Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">命令详解</span></a></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Docker/">Docker</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-04-25T04:06:00.000Z">2022-04-25</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Dockerfile</span></h1>
<h3 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h3><p>Dockerfile就是一些包含linux命令的文件，Docker通过Dockerfile读取文件中的命令来组件镜像</p>
<h3 id="Dockerfile文件内容结构"><a href="#Dockerfile文件内容结构" class="headerlink" title="Dockerfile文件内容结构"></a>Dockerfile文件内容结构</h3><p>dockerfile一般有四个组成部分：</p>
<ol>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令和容器启动时执行指令（#号为注释部分）</li>
</ol>
<h3 id="运行Dockerfile"><a href="#运行Dockerfile" class="headerlink" title="运行Dockerfile"></a>运行Dockerfile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image_name:tag_name .</span><br></pre></td></tr></table></figure>

<p>也可以通过 -f 参数来指定Dockerfile的文件位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/Dockerfile .</span><br></pre></td></tr></table></figure>



<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><p><code>FROM</code>: 指定基础镜像，必须为第一个命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">FROM &lt;image&gt;</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">FROM centos:7.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MAINTAINER</code>: 维护者信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">MAINTAINER &lt;name&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">MAINTAINER answer0732</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>RUN</code>: 构建镜像时执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	RUN &lt;command&gt;*exec执行*</span><br><span class="line">	</span><br><span class="line">格式：</span><br><span class="line">	RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	RUN [&quot;/bin/executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">	RUN apt install nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ADD</code>: 将本地文件添加到容器中，tar类型文件会自动解压（网络压缩资源不会被解压）, 可以访问网络资源，类似wget</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	ADD &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">	ADD [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径</span><br><span class="line">	</span><br><span class="line">示例：</span><br><span class="line">	ADD tes* /mydir/           # 添加所有以&quot;tes&quot;开头的文件</span><br><span class="line">	ADD tes?.txt /mydir/       # ? 替代一个单字符， 例如：&quot;test.txt&quot;</span><br><span class="line">	ADD test relativeDir/      # 添加 &quot;test&quot; 到 &quot;WORKDIR&quot;/relativeDir/</span><br><span class="line">	ADD test /absoluteDir/     # 添加 &quot;test&quot; 到 /absoluteDir/</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">	第一个参数为宿主机文件路径 第二个参数为容器路径</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>COPY</code>: 功能类似<code>ADD</code>, 但不会自动解压文件，也不能访问网络资源</p>
<p><code>CMD</code>: 构建容器后调用， 也就时在容器启动时才执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (执行可执行文件，优先)</span><br><span class="line">	CMD [&quot;param1&quot;, &quot;param2&quot;] (设置了ENTRYPOINT, 则直接调用ENTRYPOINT添加参数)</span><br><span class="line">	CMD command param1 param2 (执行shell内部命令)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	CMD echo &quot;this is test&quot; | wc -</span><br><span class="line">	CMD echo [&quot;/usr/bin/wc&quot;, &quot;--help&quot;]</span><br><span class="line">	</span><br><span class="line">注:</span><br><span class="line">	CMD不同于RUN, CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>ENTRYPOINT</code>: 配置容器, 使其可执行化 。配合CMD可省去”application”, 只使用参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] （可执行文件， 优先）</span><br><span class="line">	ENTRYPOINT command param1 param2 (shell内部命令)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	FROM Ubuntu</span><br><span class="line">	ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">	CMD [&quot;-c&quot;]</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">	ENTRYPOINT与CMD非常类似，不同的是通过docker run 执行的命令不会覆盖ENTRYPOINT, 而docker run 命令中指定的任何参数，都会被当作参数</span><br><span class="line">	再次传递给ENTRYPOINT. Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，只执行最后一个.</span><br><span class="line">	docker run -itd --name nginx echo &quot;hello world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>LABEL</code>: 用于为镜像添加元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	LABEL &lt;key&gt;&lt;value&gt; &lt;key&gt;&lt;value&gt; &lt;key&gt;&lt;value&gt; ...</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	LABEL version=&quot;1.0&quot; description=&quot;这是一个nginx镜像&quot;</span><br><span class="line">	</span><br><span class="line">注：</span><br><span class="line">	使用LABEL指定元数据时，一条LABEL可以指定一或多条元数据，指定多条时通过空格分隔。推荐将所有元数据通过一条LABEL指定，避免生成过多中间镜像。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>ENV</code> : 设置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	ENV &lt;key&gt; &lt;value&gt;    # key之后的所有内容均会被视为value的组成部分，因此一次只能设置一个变量</span><br><span class="line">    ENV &lt;key&gt;&lt;value&gt;...  # 可以设置多个变量，每个变量为一个&quot;&lt;key&gt;&lt;value&gt;的键值对&quot;，如果&lt;key&gt;中包含空格, 可以使用\来进行转义。也可以</span><br><span class="line">    通过&quot;&quot;来进行标示。另外，反斜线也可以用来续行</span><br><span class="line">    </span><br><span class="line">示例：</span><br><span class="line">	ENV myName Join Doe</span><br><span class="line">	ENV myDog Rex The Dog</span><br><span class="line">	ENV myCat=fluffy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>EXPOSE</code> : 指定与外界交互的端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	EXPOSE 80 443</span><br><span class="line">	EXPOSE 8000</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">	EXPOSE并不会让容器的端口访问到主机， 要使其可访问，需要在docker run 运行容器时通过-p来发布这些端口，或通过-p参数来发布EXPOSE导出的所有端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>VOLUME</code> : 用于指定持久化目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	VOLUME [&quot;/path/to/dir&quot;]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	VOLUME [&quot;/data&quot;]</span><br><span class="line">	VOLUME [&quot;/var/www&quot;, &quot;/var/log/nginx&quot;, &quot;/etc/nginx&quot;]</span><br><span class="line">	</span><br><span class="line">注：</span><br><span class="line">	一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有一下功能：</span><br><span class="line">	1. 卷可以在容器间共享和重用</span><br><span class="line">	2. 容器并不一定要和其他容器共享卷</span><br><span class="line">	3. 修改卷后会立即生效</span><br><span class="line">	4. 对卷的修改不会对镜像产生影响</span><br><span class="line">	5. 卷会一直存在， 知道没有任何容器使用它</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><code>WORKDIR</code> : 工作目录，类似于cd命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	WORKDIR /path/to/workdir</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	WORKDIR /usr/local/  #这时工作目录为/usr/local/</span><br><span class="line">	WORKDIR nginx 		 #这时工作目录为/usr/local/nginx</span><br><span class="line">	WORKDIR sbin         #这时工作目录为/usr/local/nginx/bin</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">	通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN,CMD,ENTRYPOINT,ADD,COPY等命令都会在该目录下执行。在使用docker run 运行容器时，可以通过</span><br><span class="line">	-w 参数覆盖构建时所设置的工作目录。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>USER</code> : 指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。</p>
<p>使用USER指定用户时，可以使用用户名，UID或GID，或两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	USER user</span><br><span class="line">	USER user:group</span><br><span class="line">	USER uid</span><br><span class="line">	USER uid:gid</span><br><span class="line">	USER user:gid</span><br><span class="line">	USER uid:group</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	USER www</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">	使用USER指定用户后，Dockerfile中其后的命令RUN,CMD,ENTRYPOINT都将使用该用户。镜像构建完成后，通过Docker run运行容器时，可以通过-u参数</span><br><span class="line">	覆盖所指定用户。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ARG</code> : 用于指定传递给构建运行时的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	ARG &lt;name&gt;[&lt;default value&gt;]</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	ARG site</span><br><span class="line">	ARG build_user=www</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ONBUILD</code>: 用于设置镜像触发器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">	ONBUILD [INSTRUCTION]</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	ONBUILD ADD . /app/src</span><br><span class="line">	ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">	当所构建的镜像被用作其他镜像的基础镜像，该镜像中的触发器将被触发</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2022/04/24/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">Docker的基本操作<span class="note">较早</span></a><div class="line"></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://example.com/">@answer0732</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1" title="v1.6.1">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.6.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
